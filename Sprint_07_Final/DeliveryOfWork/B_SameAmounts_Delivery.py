"""
ID 69033908

Описание алгоритма:
За основу взят алгоритм разбиения множества чисел
https://ru.wikipedia.org/wiki/Задача_разбиения_множества_чисел

1. Считаем сумму всех элементов последовательности
2. Если сумма нечетная, то разбить последовательность с выполнением условий
   задачи нельзя. Возвращаем False
3. Находим половину суммы и инициализируем массив:
   - первый элемент - True (сумма пустого множества равна 0)
   - остальные элементы - False
   - длина массива равна половине суммы элементов последовательности + 1
4. Для каждого элемента последовательности определяем какие суммы могут быть
   составлены из него и ранее обработанных элементов последовательности.
   Проверяем, если в какой-то момент может быть составлена сумма, равная
   половине суммы элементов последовательности и обрабатывается последний
   элемент массива, то возвращаем True.
5. Возвращаем значение последнего элемента массива: True - если полусумму
   элементов последовательности можно составить, False - в противном случае.

Вычислительная сложность:
1. Вычисление суммы элементов массива - O(n)
2. Заполнение массива - в худшем случае O(n(n/2)): n - перебираем все элементы
   последовательности, n/2 - для каждого элемента последовательности
   рассчитываем все элементы массива.
3. Общая вычислительная сложность - O(n+n(n/2))

Пространственная сложность:
1. Хранение исходных данных - O(n)
2. Хранение массива - O(n/2)
3. Общая пространственная сложность - O(n+n/2)
"""


def main():
    n = int(input())
    iData = list(map(int, input().split()))
    datasum = sum(iData)
    if datasum % 2 != 0:
        return False
    else:
        datahalfsum = datasum // 2
        dp = [True] + [False] * datahalfsum
        for num in iData:
            for j in range(datahalfsum, num - 1, -1):
                dp[j] = dp[j] or dp[j - num]
                if j == datahalfsum and dp[j]:
                    return True

        return dp[-1]


if __name__ == '__main__':
    print(main())
