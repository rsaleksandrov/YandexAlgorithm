"""
ID 67334203

В основе алгоритма лежит алгоритм бинарного поиска с более сложным определением
в какую сторону двигаться на следующем шаге.

Описание алгоритма поиска:
1. Находим индекс элемента в середине массива mid.
2. Проверяем, совпадаемт ли этот элемент с искомым. Если совпадает,
   то возвращаем mid и завершаем поиск
3. Сравниваем значения элемента с индексом mid и последнего элемента.
   Если элемент с индексом mid меньше последнего элемента, переходим к
   пункту 4, иначе к пункту __.
4. Проверяем, лежит ли искомый элемент между элементом с индексом mid и
   последним элементов (включая его). Если да, то смещаем левую границу
   на элемент, следующий за элементом с индексом mid и переходим к пункту 1.
   Если нет, смещаем правую границу на элемент, предшествующий элементу
   с индексом mid и переходим к пункту 1.
5. Проверяем, лежит ли искомый элемент между первым элементом (включая его)
   и элементом с индексом mid. Если да, смещаем правую границу на элемент,
   предшествующий элементу с индексом mid и переходим к пункту 1.
   Если нет, то смещаем левую границу на элемент, следующий за элементом с
   индексом mid и переходим к пункту 1.
   В пунктах 4 и 5 элемент с индексом mid в проверяемый диапозон не включается,
   так как его мы проверили раньше.
6. Цикл повторяется до тех пор, пока левая граница меньше или равна правой.
7. Если мы вышли из цикла, то искомого элемента в массиве нет и возвращаем -1.

Вычислительная сложность:
Так как в основе алгоритма лежит алгоритм бинарного поиска с худшей сложностью
O(log n), а операции сравнения элементов и смещения границ имеют сложность O(1),
то общая сложность алгоритма - O(log n).

Пространственная сложность:
Так как в процессе работы алгоритм использует "фиксированный" объем памяти,
который не зависит от размера массива, то пространственная сложность алгоритма
O(1).
"""


def broken_search(pArray, value) -> int:
    lb = 0
    rb = len(pArray) - 1
    while lb <= rb:
        mid = (lb + rb) // 2
        if pArray[mid] == value:
            return mid
        if pArray[mid] < pArray[rb]:
            if pArray[mid] < value <= pArray[rb]:
                lb = mid + 1
            else:
                rb = mid - 1
        else:
            if pArray[lb] <= value < pArray[mid]:
                rb = mid - 1
            else:
                lb = mid + 1
    return -1


if __name__ == '__main__':
    n = int(input())
    k = int(input())
    iData = list(map(int, input().split()))
    try:
        # В общем случае использовать бинарный поиск оптимальнее.
        # Но здесь данный вызов использовался исключительно в целях проверки
        # корректности работы алгоритма broken_search и в итоговых тестах
        # не участвует.
        kId = iData.index(k)
    except ValueError:
        kId = -1
    print(kId, broken_search(iData, k))

