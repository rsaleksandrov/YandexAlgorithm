"""
ID 67277315

При решении задачи испльзовался метод быстрой сортировки без использования
дополнителной памяти, а так же особенность Python, связанная с возможностью
сравнения списков.

При считывании входных данных формируем список, состящий из трех элементов:
- количество решенных задач. Так как нам надо по этому параметру сортировать
  по убыванию, то это значение добавляем со знаком '-'.
- размер штрафа. Так как сортировка по возрастанию, то добавляем как есть.
- имя студента. По условиям задачи оно состоит из маленьких латинских букв, то
  при сортировке от меньшего к большему получим лексикографический порядок.
  Добавляем как есть.

Работа алгоритма сортировки описана в комментариях к нему.

Вычислительная сложность:
Средняя вычислительная сложность составляет O(n log n).

Пространственная сложность:
Так как алгоритм сортировки работает на исходном массиве без выделения
дополнительной памяти. Но поскольку он рекурсивный, то на каждый вызов
тратится память стека. Чем больше исходный массив данных, тем будет больше
глубина рекурсии. Так как исходный массив делится пополам и вызов
осуществляется для обеих частей, то пространственную сложность можно
оценить как O(n).
Пространственная сложность всей программы зависит от объема входных данных и
дополнительной памяти, затраченной на рекурсивные вызовы.
Следовательно ее можно оценить как O(n)+O(n) = O(2*n) ==> O(n).
"""


def effectivQuickSort(pData, pLb, pRb):
    # В качестве опорного элемента берем средний
    pivot = pData[(pLb + pRb) // 2]
    idL = pLb
    idR = pRb
    # Работаем, пока указатели не всретятся или поменяются местами
    while idL <= idR:
        # Находим элемент, который меньше опорного
        while pData[idL] < pivot:
            idL += 1
        # Находим элемент, который больше опорного
        while pData[idR] > pivot:
            idR -= 1
        # Если указатели еще не поменялись местами
        if idL <= idR:
            # Меняем элементы местами и сдвигаем индексы
            pData[idL], pData[idR] = pData[idR], pData[idL]
            idL += 1
            idR -= 1
    # Если правый индекс не ушел за левую границу, то сортируем левую половину
    if idR >= pLb:
        effectivQuickSort(pData, pLb, idR)
    # Если левый индекс не ушел за правую границу, то сортируем правую половину
    if idL < pRb:
        effectivQuickSort(pData, idL, pRb)


if __name__ == '__main__':
    n = int(input())
    iStudents = []
    for i in range(n):
        sName, sP, sF = input().split()
        iStudents.append([-int(sP), int(sF), sName])
    effectivQuickSort(iStudents, 0, len(iStudents) - 1)
    for i in range(n):
        print(iStudents[i][2])
